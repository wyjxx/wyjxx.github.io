<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /> 
  <title>Clue + Location Map</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    svg { border: 1px solid #ccc; }
    .node text { pointer-events: none; font-size: 10px; text-anchor: middle; font-weight: bold; }
    .link { stroke: #ccc; stroke-width: 1px; }
    .vi-visited { fill: #ffe600c9; }
    .normal { fill: none; }
    .excluded { fill: #ff2222bd !important; }
    .included { fill: #ffe600c9 !important; }
    .concluded { fill: #217df6be !important; }
    svg .vi-current { fill: #ffe600c9; stroke: #000 !important; stroke-width: 2px !important; transform: scale(1.2); transition: transform 0.2s; }
    svg .l-current { stroke: #000 !important; stroke-width: 2px !important; transform: scale(1.2); transition: transform 0.2s; }
    svg .hover-related, svg .hover-location { stroke: rgb(252,154,33) !important; stroke-width: 3px !important; transform: scale(1.6); transition: transform 0.2s; }

    /* Reasoning box (fixed height + scroll) */
    #reasoningBox { max-width: 100%; height: 160px; overflow: auto; font-size: 14px; line-height: 1.6; color: #222; }

    /* Make square map areas that fully fit */
    .square { position: relative; width: 100%; }
    .square::before { content: ""; display: block; padding-top: 100%; } /* 1:1 aspect */
    .square > svg { position: absolute; inset: 0; width: 100%; height: 100%; }

    /* Keep legend narrower (~1/6 width on xl+) */
    @media (min-width: 1200px) {
      .col-legend { flex: 0 0 auto; width: 12.5%; }
    }
  </style>
</head>
<body class="bg-light">

<nav class="navbar navbar-expand-lg bg-white border-bottom sticky-top">
  <div class="container-fluid">
    <span class="navbar-brand fw-semibold">Clue &amp; Location Map</span>
    <div class="ms-auto d-flex align-items-center gap-3 flex-wrap">
      <div class="d-flex align-items-center">
        <label for="stepInput" class="form-label me-2 mb-0">Step</label>
        <input type="range" id="stepInput" class="form-range" min="1" max="16" value="1" style="width:200px;">
        <span id="stepDisplay" class="badge text-bg-secondary ms-2">1</span>
      </div>
      <button id="autoPlayBtn" class="btn btn-outline-primary">â–¶</button>
      <div class="form-check form-switch mb-0">
        <input class="form-check-input" type="checkbox" id="toggleVisitedCount" checked>
        <label class="form-check-label" for="toggleVisitedCount">Visited Count</label>
      </div>
      <div class="d-flex align-items-center">
        <label for="modelSelect" class="form-label me-2 mb-0">Model</label>
        <select id="modelSelect" class="form-select form-select-sm">
          <option value="chatgpt">ChatGPT</option>
          <option value="claude">Claude</option>
          <option value="gemini">Gemini</option>
        </select>
      </div>
    </div>
  </div>
</nav>

<!-- Reasoning Text + Picture -->
<div class="row g-3">
  <!-- Reasoning Text -->
  <div class="col-6 col-lg-6">
    <div class="card shadow-sm h-100">
      <div class="card-header py-2">
        <span class="fw-semibold">Reasoning Text</span>
      </div>
      <div class="card-body">
        <div id="reasoningBox" style="height: 160px; overflow:auto; font-size: 14px; line-height: 1.6; color: #222;"></div>
      </div>
    </div>
  </div>

  <!-- Picture-->
  <div class="col-6 col-lg-6">
    <div class="card shadow-sm h-100">
      <div class="card-header py-2">
        <span class="fw-semibold">Picture</span>
      </div>
      <div class="card-body d-flex flex-row align-items-start gap-3">
        <select id="picSelect" class="form-select form-select-sm" style="max-width: 90px;"      onchange="selectFromMenu(this)">
          <option value="">All</option>
        </select>
        <div>
          <div class="input-group input-group-sm">
            <input id="imgInput" type="text" class="form-control" placeholder="e.g. p1, p2">
            <button class="btn btn-primary" onclick="selectImage()">Select</button>
          </div>
          <div id="imgError" class="text-danger small"></div>
        </div>
        <img id="cornerImg" src="" alt="picture" class="rounded border"
             style="max-height: 140px; display:none; object-fit: cover;">
        <div id="groundtruthBox" class="mt-2 small text-muted"></div>
      </div>
    </div>
  </div>
</div>



  <!-- Main layout: Legend at left, Clue Map center, Location Map right. Both maps square. -->
  <div class="row g-3 mt-1">

    <!-- Clue Map center -->
    <div class="col-12 col-lg-4 col-xl-5">
      <div class="card shadow-sm h-100">
        <div class="card-header py-2"><span class="fw-semibold">Clue Map</span></div>
        <div class="card-body">
          <div class="square">
            <svg id="svg-vi" viewBox="0 0 600 600" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
        </div>
      </div>
    </div>

    <!-- Location Map right -->
    <div class="col-12 col-lg-4 col-xl-5">
      <div class="card shadow-sm h-100">
        <div class="card-header py-2"><span class="fw-semibold">Location Map</span></div>
        <div class="card-body">
          <div class="square">
            <svg id="svg-l" viewBox="0 0 600 600" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
        </div>
      </div>
    </div>

    <!-- Legend column -->
    <div class="col-12 col-lg-4 col-xl-2 col-legend">
      <div class="card shadow-sm h-100">
        <div class="card-header py-2"><span class="fw-semibold">Legend</span></div>
        <div class="card-body p-0">
          <ul class="list-group list-group-flush small">
            <li class="list-group-item fw-semibold">Clue Map</li>
            <li class="list-group-item">â¬› Visual Element</li>
            <li class="list-group-item">â–¶ Inference Clue</li>
            <li class="list-group-item"><span style="color:#000; font-weight:bold;">ã€‡</span> Current Step</li>
            <li class="list-group-item fw-semibold">Location Map</li>
            <li class="list-group-item">ðŸ”´ Excluded Location</li>
            <li class="list-group-item">ðŸŸ¡ Included Location</li>
            <li class="list-group-item">ðŸ”µ Concluded Location</li>
            <li class="list-group-item"><span style="color:#000; font-weight:bold;">ã€‡</span> Current Step</li>
            <li class="list-group-item"><span style="color:#ff2222; font-weight:bold;">âœ±</span> Status Changed (Self-Reflection)</li>
            <li class="list-group-item"><span style="color:#ff2222; font-weight:bold;">?</span> No-Clue Location (Reasoning Gap)</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  let viLayout, lLayout, matchData;
  let reasoningData = [];
  let showVisitedCount = true;
  let autoPlayInterval = null;
  let gpsData = {};

  fetch('pictures/gps.json')
    .then(res => res.json())
    .then(data => { gpsData = data; })
    .catch(err => console.error("Failed to load gps.json:", err));
 
  // wrap text to fit within a certain length
  function wrapText(text, maxLen = 12) {
    const words = text.split(" ");
    const lines = []; let line = "";
    for (let word of words) {
      if ((line + " " + word).length > maxLen) { 
        lines.push(line); 
        line = word; 
      }
      else { 
        line += (line ? " " : "") + word; 
      }
    }
    if (line) lines.push(line);
    return lines.join("\n");
  }
  

  // select image
  function selectImage() {
    const imgId = document.getElementById('imgInput').value.trim();
    if (!imgId) return;
    const imgPathPng = `pictures/${imgId}.png`;
    const imgElem = document.getElementById('cornerImg');
    const errElem = document.getElementById('imgError');
    fetch(imgPathPng, { method: 'HEAD' }).then(res => {
      if (res.ok) {
        imgElem.src = imgPathPng; imgElem.style.display = ''; errElem.innerText = '';
        loadDataAndRender(imgId);
      } else { 
        imgElem.style.display = 'none'; 
        errElem.innerText = 'Picture does not exist'; 
      }
    });
    
    // load and show gps ground truth
    if (gpsData[imgId + ".png"]) {
    const g = gpsData[imgId + ".png"];
    const gtDiv = document.getElementById("groundtruthBox");
    gtDiv.innerHTML = `
      <b>Groundtruth:</b><br>
      Country: ${g.COUNTRY || "?"}<br>
      City: ${g.CITY || "?"}<br>
      Street: ${g.STREET || "?"}
    `;
    } else {
      document.getElementById("groundtruthBox").innerHTML = "<i>No groundtruth</i>";
    }

  }

  // select from menu
  function selectFromMenu(sel) {
    if (sel.value) {
      document.getElementById('imgInput').value = sel.value;
      selectImage();
    }
  }
  

// fetch pic menu list from index.json
fetch('pictures/index.json')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(pictureFiles => {
    
    const picSelect = document.getElementById('picSelect');

    pictureFiles.forEach(fileName => {
 
      const optionValue = fileName.split('.')[0];
      const option = document.createElement('option');
      option.value = optionValue;      // e.g., value="p1"
      option.textContent = optionValue; // e.g., <option>p1</option>
      
      picSelect.appendChild(option);
    });
  })
  .catch(error => {
    console.error('Error:', error);
  });
  

   // Load JSON files and Render
  function loadDataAndRender(imgId) {
    const model = document.getElementById("modelSelect").value || "chatgpt";
    Promise.all([
      fetch(`data/${model}/${imgId}/vi_map_layout.json`).then(res => res.json()),
      fetch(`data/${model}/${imgId}/l_map_layout.json`).then(res => res.json()),
      fetch(`data/${model}/${imgId}/para_match.json`).then(res => res.json()),
      fetch(`data/${model}/${imgId}/reasoning.json`).then(res => res.json())
    ]).then(([vi, l, match, reasoning]) => {
      viLayout = vi; 
      lLayout = l; 
      matchData = match; 
      reasoningData = reasoning;
      document.getElementById("stepInput").max = match.length;
      renderBoth();
    });
  }

  // Render both graphs
  function renderBoth() {
    // show reasoning paragraph
    const step = parseInt(document.getElementById("stepInput").value);
    let reasoningText = "";
    if (reasoningData && reasoningData[step - 1]) {
      reasoningText = `<b>Step ${step} Reasoning: </b> ${reasoningData[step - 1].content}`;
    }
    document.getElementById("reasoningBox").innerHTML = reasoningText;
    // render Graphs
    renderGraph("svg-vi", viLayout, "vi");
    renderGraph("svg-l", lLayout, "l");
  }

  // Update step display and re-render on input change
  document.getElementById("stepInput").addEventListener("input", function () {
    const val = this.value; 
    document.getElementById("stepDisplay").innerText = val; renderBoth();
  });
  // Update Visited Count
  document.getElementById("toggleVisitedCount").addEventListener("click", () => { 
    showVisitedCount = !showVisitedCount; 
    renderBoth(); 
  });
  // Update Auto Play
  document.getElementById("autoPlayBtn").addEventListener("click", () => {
    const stepInput = document.getElementById("stepInput");
    const maxStep = parseInt(stepInput.max);
    
    if (autoPlayInterval) { 
      // on playing, click to stop
      clearInterval(autoPlayInterval); 
      autoPlayInterval = null; 
      document.getElementById("autoPlayBtn").innerText = "â–¶"; 
    } else {
      autoPlayInterval = setInterval(() => {
        let current = parseInt(stepInput.value);
        if (current < maxStep) { 
          stepInput.value = current + 1; 
          document.getElementById("stepDisplay").innerText = current + 1; 
          renderBoth(); 
        }
        else { 
          // automatically stopped
          clearInterval(autoPlayInterval); 
          autoPlayInterval = null; 
          document.getElementById("autoPlayBtn").innerText = "â–¶"; 
        }
      }, 1500); // set seconds per frame
      document.getElementById("autoPlayBtn").innerText = "â¸";
    }
  });

  // Render single graph
  function renderGraph(svgId, layoutData, mode) {
    if (!layoutData) return;
    const svg = d3.select(`#${svgId}`);
    svg.selectAll("*").remove();

    // Use the actual pixel size of the square container
    const bbox = svg.node().getBoundingClientRect();
    const width = bbox.width, height = bbox.height; // guaranteed square by CSS

    // Calculate scale and offset
    const allX = layoutData.map(d => d.x);
    const allY = layoutData.map(d => d.y);
    const minX = Math.min(...allX), maxX = Math.max(...allX);
    const minY = Math.min(...allY), maxY = Math.max(...allY);
    const scale = Math.min((width - 100) / (maxX - minX || 1), (height - 100) / (maxY - minY || 1));
    const offsetX = width / 2 - ((minX + maxX) / 2) * scale;
    const offsetY = height / 2 - ((minY + maxY) / 2) * scale;
    
    // layout data to scaled coordinates on screen
    const nodes = layoutData.map(d => ({ ...d, fx: d.x * scale + offsetX, fy: d.y * scale + offsetY }));

    // Create force simulation
    const simulation = d3.forceSimulation(nodes)
      .force("x", d3.forceX(d => d.fx).strength(0.05))
      .force("y", d3.forceY(d => d.fy).strength(0.05))
      .force("collide", d3.forceCollide(18))
      .stop();
    for (let i = 0; i < 300; ++i) simulation.tick();
    
    // Create a group g for the graph
    const g = svg.append("g");

    // center point of rings
    const centerX = 0 * scale + offsetX; 
    const centerY = 0 * scale + offsetY;

    // Draw dashed granularity rings by mode
    const maxGranularity = mode === "l" ? 5 : 3;
    for (let r = 1; r <= maxGranularity; r++) {
      g.append("circle")
      .attr("cx", centerX)
      .attr("cy", centerY)
      .attr("r", r * scale)
      .style("fill", "none")
      .style("stroke", "lightgray")
      .style("stroke-dasharray", "4,4");
    }

    // read step input value and load highlighted clues
    const step = parseInt(document.getElementById("stepInput").value);
    const match = matchData && matchData.find(d => d.paragraph === step);
    let highlights = new Set();
    if (match) { if (mode === "vi") highlights = new Set(match.clue); else if (mode === "l") { highlights = new Set(match["loc-clue"].map(d => d.loc)); 
    } 
  }
    const nodeMap = Object.fromEntries(layoutData.map(d => [d.entity, d]));

    // For each node, create a group
    const nodeG = g.selectAll(".node")
    .data(nodes)
    .enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${d.x},${d.y})`);

    // create current set
    let current = new Set();
    if (match) { if (mode === "vi") match.clue.forEach(e => current.add(e)); else if (mode === "l") match["loc-clue"].forEach(e => current.add(e.loc)); }

    //iterate through nodes to create visited sets
    let visited = new Set();
    let visitedNum = {};
    for (let i = 0; i < step; ++i) {
    const m = matchData.find(d => d.paragraph === i + 1);
    if (m) {
        if (mode === "vi") m.clue.forEach(e => {
          visited.add(e);
          visitedNum[e] = (visitedNum[e] || 0) + 1;
        });
        else if (mode === "l") m["loc-clue"].forEach(e => {
          visited.add(e.loc);
          visitedNum[e.loc] = (visitedNum[e.loc] || 0) + 1;
        });
    }
    }
    // for l: update location status: excluded, included, concluded
    let locStatus = {}; 
    let locStatusChange = {};

    for (let i = 0; i < step; ++i) {
      const m = matchData.find(d => d.paragraph === i + 1);
      if (m && m['loc-clue']) {
        m['loc-clue'].forEach(l => {
          const prevStatus = locStatus[l.loc];
          locStatus[l.loc] = l.status;
  
          //console.log('Step:',i+1,' Location:', l.loc,' PrevStatus:',prevStatus,' CurrentStatus:',l.status);
          if(prevStatus !== undefined && prevStatus !== l.status && i === step - 1) { 
            locStatusChange[l.loc] = true; 
          }
        });
      }
    }

    function drawLinkTo(node){
      if(!node) return null;
      if(!visited.has(node.entity) && !current.has(node.entity)) return drawLinkTo(nodeMap[node.parent]);
      else return node;
    }

    // Draw links through parent-child relationships
    layoutData.forEach(d => {
      if (visited.has(d.entity) || current.has(d.entity)){

        const source = nodes.find(n => n.entity === d.entity);
        const targetNode = drawLinkTo(nodeMap[d.parent]);
        const target = targetNode ? nodes.find(n => n.entity === targetNode.entity) : null;

        if (source && target && source.entity !== target.entity && d.parent && nodeMap[d.parent]) {
          g.append("line")
          .attr("class", "link")
          .attr("x1", source.x)
          .attr("y1", source.y)
          .attr("x2", target.x)
          .attr("y2", target.y);
        }
      }
    });

    // Draw nodes with different shapes based on type
    nodeG.append(d => {
    if (d.type === "v") return document.createElementNS(d3.namespaces.svg, "rect");
    if (d.type === "i") return document.createElementNS(d3.namespaces.svg, "path");
    return document.createElementNS(d3.namespaces.svg, "circle");
    })
    .attr("r", 6)
    .attr("width", 12)
    .attr("height", 12)
    .attr("x", -6)
    .attr("y", -6)
    .attr("d", d => d.type === "i" ? d3.symbol().type(d3.symbolTriangle).size(100)() : null)
    .classed("normal", d => !visited.has(d.entity) && !current.has(d.entity))
    .classed("vi-current", d => d.type !="l" && current.has(d.entity))
    .classed("vi-visited", d => d.type !="l" && visited.has(d.entity) && !current.has(d.entity))
    .classed("l-current", d => d.type ==="l" && current.has(d.entity))
    .classed("excluded", d => locStatus[d.entity] === 1)
    .classed("included", d => locStatus[d.entity] === 2)
    .classed("concluded", d => locStatus[d.entity] === 3)
    
    // Mark status change (self reflection)
    nodeG
    .filter(d => locStatusChange[d.entity] === true) 
    .append("text")
    .attr("dx", 12) 
    .attr("dy", 4)
    .text("âœ±")
    .attr("font-size", "30px")
    .attr("fill", "red")
    .attr("font-weight", "bold");

  // Clue-lost Location
  if (mode === "l" && match && match["loc-clue"]) {
    const noClueLocs = new Set();
    match["loc-clue"].forEach(l => {
      if (!l.related_clue || l.related_clue.length === 0) {
        noClueLocs.add(l.loc);
      }
    });
    // Mark all clue-lost locations (reasoning clip)
    nodeG
      .filter(d => noClueLocs.has(d.entity)) 
      .append("text")
      .attr("dx", -12)
      .attr("dy", 4)
      .text("?")
      .attr("font-size", "30px")
      .attr("fill", "red")
      .attr("font-weight", "bold");
  }

    
  // Add hover effect for related clues and current location nodes
  if (mode === "l") {
    // mouse hover on d
    nodeG.on("mouseover", function (event, d) {
      const step = parseInt(document.getElementById("stepInput").value);
      const match = matchData.find(m => m.paragraph === step);
      if (!match || !match["loc-clue"]) return;

      // find related_clue of loaction d.entity
      const locEntry = match["loc-clue"].find(l => l.loc === d.entity);
      if (!locEntry) return;

      const clues = new Set(locEntry.related_clue);

      // iterate through all nodes in clue graph, find and highlight related clues 
      d3.select("#svg-vi")
        .selectAll(".node")
        .each(function (d) {
          //console.log('Clue node:', d.entity, 'isRelated:', clues.has(d.entity));
          const isRelated = clues.has(d.entity);
          d3.select(this)
            .select("circle, rect, path")
            .classed("hover-related", isRelated);
        });
      
      // highlight the current location node
      d3.select(this)
      .select("circle, rect, path")
      .classed("hover-location", true);
    });
    
    nodeG.on("mouseout", function () {
      // clear all hover effect
      d3.select("#svg-vi")
        .selectAll(".node")
        .each(function () {
          d3.select(this)
            .select("circle, rect, path")
            .classed("hover-related", false);
        });
      d3.select(this)
        .select("circle, rect, path")
        .classed("hover-location", false);
    });
  }

  //Add text labels to nodes
  nodeG.append("text")
    .attr("dy", -10)
    .text(d => {
      if(!visited.has(d.entity) && !current.has(d.entity))
      return ""; 
      else return wrapText(d.entity)});
  // Add visited count to nodes
    if(showVisitedCount) {
    nodeG.append("text")
    .attr("dx", 8) 
    .attr("dy", 11) 
    .attr("fill", "gray") 
    .text(d => {
    const count = visitedNum[d.entity];
    if(count > 1) return count;
    else return "";
    });
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

