<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clue + Location Map</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: sans-serif; }
    .container { display: flex; justify-content: space-around; }
    svg { border: 1px solid #ccc; }
    .node text { pointer-events: none; font-size: 10px; text-anchor: middle; font-weight: bold; }
    .link { stroke: #ccc; stroke-width: 1px; }
    .vi-visited { fill: #ffe600c9; }     
    .normal { fill: #ccccccc0; }
    .excluded { fill: #ff2222bd !important;}
    .included { fill: #ffe600c9 !important;}
    .concluded {fill: #217df6be !important;}

    svg .vi-current {
      fill: #ffe600c9;
      stroke: rgb(0, 0, 0)!important; 
      stroke-width: 2px !important; 
      transform: scale(1.2); 
      transition: transform 0.2s; 
    } 
    svg .l-current {
      stroke: rgb(0, 0, 0) !important; 
      stroke-width: 2px !important; 
      transform: scale(1.2); 
      transition: transform 0.2s; 
    } 
    svg .hover-related, svg .hover-location { 
      stroke: rgb(252, 154, 33) !important; 
      stroke-width: 3px !important; 
      transform: scale(1.6); 
      transition: transform 0.2s; 
    }
    #reasoningBox {
      margin: 10px 0;
      font-size: 14px;
      font-weight: bold;
      font-family: 'Charter', serif;
      max-width: 1000px;
      height: 120px;
      line-height: 1.6;
      color: #222;
    }
    #cornerImg {
      position: absolute;
      top: 40px;
      right: 40px;
      width: 300px;
      max-height: 250px;
      border-radius: 4px;
      z-index: 10;
    }
  </style>
</head>
<body>
<div style="position: absolute; top: 20px; right: 40px; text-align: right;">
  <input id="imgInput" type="text" placeholder="picture: p1, p2..." style="width:100px;">
  <button onclick="selectImage()">Select</button>
  <br>
  <img id="cornerImg" src="" alt="picture">
  <div id="imgError" style="color:red; font-size:12px;"></div>
</div>
  <h2>Clue & Location Map</h2>
  <div id="reasoningBox"></div>
  <div>
  Step: <input type="range" id="stepInput" min="1" max="16" value="1" />
  <span id="stepDisplay">1</span>
  <button id="autoPlayBtn" style="margin-left: 12px;">▶</button>
  <label style="margin-left: 12px; font-size: 14px;">
    <input type="checkbox" id="toggleVisitedCount" checked />
    Visited Count
  </label>
  </div>
  <div class="container">
    <div>
      <h3>Clue Map</h3>
      <svg id="svg-vi" width="600" height="600"></svg>
    </div>
    <div>
      <h3>Location Map</h3>
      <svg id="svg-l" width="600" height="600"></svg>
    </div>
  </div>
<div style="margin-top: 20px; padding: 10px; font-size: 14px; max-width: 1200px;">
  <h3>Legend</h3>
  <ul style="list-style: none; padding-left: 0;">
    <li>Clue Map</li>  
    <li>⬛ Visual Element</li>
    <li>▶ Inference Clue</li>
    <li>🟡 Visited</li>
    <li><span style="color:#000; font-weight:bold;">〇</span> Current Step</li>
    <li>Location Map</li>
    <li>🔴 Excluded Location</li>
    <li>🟡 Included Location</li>
    <li>🔵 Concluded Location</li>
    <li><span style="color:#000; font-weight:bold;">〇</span> Current Step</li>
    <li><span style="color:#ff2222; font-weight:bold;">✱</span> Status Changed (Self-Reflection)</li>
    <li><span style="color:#ff2222; font-weight:bold;">?</span> No-Clue Location (Reasoning Clip)</li>
  </ul>
</div>

  <script>
    let viLayout, lLayout, matchData;
    let reasoningData = [];
    let showVisitedCount = true;
    let autoPlayInterval = null;

    
    // wrap text to fit within a certain length
    function wrapText(text, maxLen = 12) {
      const words = text.split(" ");
      const lines = [];
      let line = "";
      for (let word of words) {
        if ((line + " " + word).length > maxLen) {
          lines.push(line);
          line = word;
        } else {
          line += (line ? " " : "") + word;
        }
      }
      if (line) lines.push(line);
      return lines.join("\n");
    }
    
    // select image
    function selectImage() {
      const imgId = document.getElementById('imgInput').value.trim();
      if (!imgId) return;
      const imgPathPng = `data/pictures/${imgId}.png`;
      const imgElem = document.getElementById('cornerImg');
      const errElem = document.getElementById('imgError');
      fetch(imgPathPng, { method: 'HEAD' }).then(res => {
      if (res.ok) {
        imgElem.src = imgPathPng;
        imgElem.style.display = '';
        errElem.innerText = '';
        loadDataAndRender(imgId);
      } else {
        imgElem.style.display = 'none';
        errElem.innerText = 'Picture does not exist';
      }
     });
    }

    // Load JSON files and Render
    function loadDataAndRender(imgId) {
      Promise.all([
        fetch(`data/${imgId}/vi_map_layout.json`).then(res => res.json()),
        fetch(`data/${imgId}/l_map_layout.json`).then(res => res.json()),
        fetch(`data/${imgId}/para_match.json`).then(res => res.json()),
        fetch(`data/${imgId}/reasoning.json`).then(res => res.json())
      ]).then(([vi, l, match, reasoning]) => {
        viLayout = vi;
        lLayout = l;
        matchData = match;
        reasoningData = reasoning;
        document.getElementById("stepInput").max = match.length;
        renderBoth();
      });
    }

    // Render both graphs
    function renderBoth() {
      // show reasoning paragraph
      const step = parseInt(document.getElementById("stepInput").value);
      let reasoningText = "";
      if (reasoningData && reasoningData[step - 1]) {
        reasoningText = `<b>Step ${step} Reasoning: </b> ${reasoningData[step - 1].content}`;
      }
      document.getElementById("reasoningBox").innerHTML = reasoningText;
      // render Graphs
      renderGraph("svg-vi", viLayout, "vi");
      renderGraph("svg-l", lLayout, "l");
    }
    
    // Update step display and re-render on input change
    document.getElementById("stepInput").addEventListener("input", function () {
        const val = this.value;
        document.getElementById("stepDisplay").innerText = val;
        renderBoth();
    });
    // Update Visited Count
    document.getElementById("toggleVisitedCount").addEventListener("click", () => {
      showVisitedCount = !showVisitedCount;
      renderBoth();
    });
      // Update Auto Play
      document.getElementById("autoPlayBtn").addEventListener("click", () => {
      const stepInput = document.getElementById("stepInput");
      const maxStep = parseInt(stepInput.max);

      if (autoPlayInterval) {
        // on playing, click to stop
        clearInterval(autoPlayInterval);
        autoPlayInterval = null;
        document.getElementById("autoPlayBtn").innerText = "▶";
      } else {
        // start
        autoPlayInterval = setInterval(() => {
          let current = parseInt(stepInput.value);
          if (current < maxStep) {
            stepInput.value = current + 1;
            document.getElementById("stepDisplay").innerText = current + 1;
            renderBoth();
          } else {
            // automatically stopped
            clearInterval(autoPlayInterval);
            autoPlayInterval = null;
            document.getElementById("autoPlayBtn").innerText = "▶";
          }
        }, 2000); // 2 s per frame
        document.getElementById("autoPlayBtn").innerText = "⏸";
      }
    });



    
    // Render single graph
    function renderGraph(svgId, layoutData, mode) {
      const svg = d3.select(`#${svgId}`);
      svg.selectAll("*").remove();
      const width = +svg.attr("width"), height = +svg.attr("height");
      
      // Calculate scale and offset
      const allX = layoutData.map(d => d.x);
      const allY = layoutData.map(d => d.y);
      const minX = Math.min(...allX), maxX = Math.max(...allX);
      const minY = Math.min(...allY), maxY = Math.max(...allY);
      const scale = Math.min((width - 100) / (maxX - minX), (height - 100) / (maxY - minY));
      const offsetX = width / 2 - ((minX + maxX) / 2) * scale;
      const offsetY = height / 2 - ((minY + maxY) / 2) * scale;
      
      // layout data to scaled coordinates on screen 
      const nodes = layoutData.map(d => ({
        ...d,
        fx: d.x * scale + offsetX,
        fy: d.y * scale + offsetY
      }));

      // Create force simulation
      const simulation = d3.forceSimulation(nodes)
        .force("x", d3.forceX(d => d.fx).strength(0.05))
        .force("y", d3.forceY(d => d.fy).strength(0.05))
        .force("collide", d3.forceCollide(18))
        .stop();
      for (let i = 0; i < 300; ++i) simulation.tick();
      
      // Create a group g for the graph
      const g = svg.append("g");
      
      // center point of rings
      const centerX = 0 * scale + offsetX;
      const centerY = 0 * scale + offsetY;

      // Draw dashed granularity rings by mode
      const maxGranularity = mode === "l" ? 5 : 3;
      for (let r = 1; r <= maxGranularity; r++) {
        g.append("circle")
          .attr("cx", centerX)
          .attr("cy", centerY)
          .attr("r", r * scale)
          .style("fill", "none")
          .style("stroke", "lightgray")
          .style("stroke-dasharray", "4,4");
      }

      // read step input value and load highlighted clues
      const step = parseInt(document.getElementById("stepInput").value);
      const match = matchData.find(d => d.paragraph === step);
      let highlights = new Set();
      if (match) {
        if (mode === "vi") highlights = new Set(match.clue);
        else if (mode === "l") {
          highlights = new Set(match["loc-clue"].map(d => d.loc));
        }
      }
      const nodeMap = Object.fromEntries(layoutData.map(d => [d.entity, d]));
      
      // Draw links through parent-child relationships
      layoutData.forEach(d => {
        if (d.parent && nodeMap[d.parent]) {
          const source = nodes.find(n => n.entity === d.parent);
          const target = nodes.find(n => n.entity === d.entity);
          if (source && target) {
            g.append("line")
              .attr("class", "link")
              .attr("x1", source.x)
              .attr("y1", source.y)
              .attr("x2", target.x)
              .attr("y2", target.y);
          }
        }
      });

      // For each node, create a group
      const nodeG = g.selectAll(".node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`);
        
        // create current set
        let current = new Set();
        if (match) {
        if (mode === "vi") match.clue.forEach(e => current.add(e));
        else if (mode === "l") match["loc-clue"].forEach(e => current.add(e.loc));
        }

        //iterate through nodes to create visited sets
        let visited = new Set();
        let visitedNum = {};
        for (let i = 0; i < step; ++i) {
        const m = matchData.find(d => d.paragraph === i + 1);
        if (m) {
            if (mode === "vi") m.clue.forEach(e => {
              visited.add(e);
              visitedNum[e] = (visitedNum[e] || 0) + 1;
            });
            else if (mode === "l") m["loc-clue"].forEach(e => {
              visited.add(e.loc);
              visitedNum[e.loc] = (visitedNum[e.loc] || 0) + 1;
            });
        }
        }

        // for l: update location status: excluded, included, concluded
        let locStatus = {};
        let locStatusChange = {};

        for (let i = 0; i < step; ++i) {
          const m = matchData.find(d => d.paragraph === i + 1);
          if (m && m['loc-clue']) {
            m['loc-clue'].forEach(l => {
              const prevStatus = locStatus[l.loc];
              locStatus[l.loc] = l.status;

              //console.log('Step:',i+1,' Location:', l.loc,' PrevStatus:',prevStatus,' CurrentStatus:',l.status);
              if(prevStatus != undefined && prevStatus != l.status && i===step-1) {
                locStatusChange[l.loc] = true;
              }
            });
          }
        }

        // Draw nodes with different shapes based on type
        nodeG.append(d => {
        if (d.type === "v") return document.createElementNS(d3.namespaces.svg, "rect");
        if (d.type === "i") return document.createElementNS(d3.namespaces.svg, "path");
        return document.createElementNS(d3.namespaces.svg, "circle");
        })
        .attr("r", 6)
        .attr("width", 12)
        .attr("height", 12)
        .attr("x", -6)
        .attr("y", -6)
        .attr("d", d => d.type === "i" ? d3.symbol().type(d3.symbolTriangle).size(100)() : null)
        .classed("normal", d => !visited.has(d.entity) && !current.has(d.entity))
        .classed("vi-current", d => d.type !="l" && current.has(d.entity))
        .classed("vi-visited", d => d.type !="l" && visited.has(d.entity) && !current.has(d.entity))
        .classed("l-current", d => d.type ==="l" && current.has(d.entity))
        .classed("excluded", d => locStatus[d.entity] === 1)
        .classed("included", d => locStatus[d.entity] === 2)
        .classed("concluded", d => locStatus[d.entity] === 3)
        
        // Mark status change (self reflection)
        nodeG
        .filter(d => locStatusChange[d.entity] === true) 
        .append("text")
        .attr("dx", 12) 
        .attr("dy", 4)
        .text("✱")
        .attr("font-size", "30px")
        .attr("fill", "red")
        .attr("font-weight", "bold");

      // Clue-lost Location
      if (mode === "l" && match && match["loc-clue"]) {
        const noClueLocs = new Set();
        match["loc-clue"].forEach(l => {
          if (!l.related_clue || l.related_clue.length === 0) {
            noClueLocs.add(l.loc);
          }
        });
        // Mark all clue-lost locations (reasoning clip)
        nodeG
          .filter(d => noClueLocs.has(d.entity)) 
          .append("text")
          .attr("dx", -12)
          .attr("dy", 4)
          .text("?")
          .attr("font-size", "30px")
          .attr("fill", "red")
          .attr("font-weight", "bold");
      }

        
      // Add hover effect for related clues and current location nodes
      if (mode === "l") {
        // mouse hover on d
        nodeG.on("mouseover", function (event, d) {
          const step = parseInt(document.getElementById("stepInput").value);
          const match = matchData.find(m => m.paragraph === step);
          if (!match || !match["loc-clue"]) return;

          // find related_clue of loaction d.entity
          const locEntry = match["loc-clue"].find(l => l.loc === d.entity);
          if (!locEntry) return;

          const clues = new Set(locEntry.related_clue);

          // iterate through all nodes in clue graph, find and highlight related clues 
          d3.select("#svg-vi")
            .selectAll(".node")
            .each(function (d) {
              //console.log('Clue node:', d.entity, 'isRelated:', clues.has(d.entity));
              const isRelated = clues.has(d.entity);
              d3.select(this)
                .select("circle, rect, path")
                .classed("hover-related", isRelated);
            });
          
          // highlight the current location node
          d3.select(this)
          .select("circle, rect, path")
          .classed("hover-location", true);
        });
        
        nodeG.on("mouseout", function () {
          // clear all hover effect
          d3.select("#svg-vi")
            .selectAll(".node")
            .each(function () {
              d3.select(this)
                .select("circle, rect, path")
                .classed("hover-related", false);
            });
          d3.select(this)
            .select("circle, rect, path")
            .classed("hover-location", false);
        });
      }

      //Add text labels to nodes
      nodeG.append("text")
        .attr("dy", -10)
        .text(d => wrapText(d.entity));
      // Add visited count to nodes
        if(showVisitedCount) {
        nodeG.append("text")
        .attr("dx", 8) 
        .attr("dy", 11) 
        .attr("fill", "gray") 
        .text(d => {
        const count = visitedNum[d.entity];
        if(count > 1) return count;
        else return "";
        });
      }
    }
  </script>
</body>
</html>
